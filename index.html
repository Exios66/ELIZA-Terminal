<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AI-Powered Terminal Emulator</title>
  <style>
    :root {
      --bg-color: #000;
      --text-color: #0f0;
      --prompt-color: #0f0;
      --highlight-color: #222;
    }

    body {
      margin: 0;
      font-family: monospace;
      background-color: var(--bg-color);
      color: var(--text-color);
    }

    #terminal {
      height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 10px;
      overflow-y: auto;
      box-sizing: border-box;
      white-space: pre-wrap;
      position: relative;
    }

    .output {
      margin-bottom: 10px;
    }

    #input-line {
      display: flex;
      align-items: center;
    }

    #prompt {
      color: var(--prompt-color);
      margin-right: 5px;
      flex-shrink: 0;
    }

    #input {
      flex-grow: 1;
      background: none;
      border: none;
      color: inherit;
      outline: none;
      font-family: inherit;
      font-size: 1rem;
    }

    .theme-switcher {
      position: fixed;
      top: 10px;
      right: 10px;
      background: var(--highlight-color);
      color: var(--text-color);
      padding: 8px 12px;
      cursor: pointer;
      border: 1px solid var(--prompt-color);
      -webkit-user-select: none;
      user-select: none;
      font-size: 0.9rem;
    }

    .hidden {
      display: none;
    }

    /* Basic scroll styling */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #333;
    }
    ::-webkit-scrollbar-thumb {
      background: #666;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #888;
    }

    /* Command suggestions dropdown */
    .suggestions-dropdown {
      position: absolute;
      bottom: 40px;
      left: 30px;
      background: var(--highlight-color);
      border: 1px solid var(--text-color);
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
      width: auto;
      min-width: 200px;
      display: none;
      z-index: 1000;
    }

    .suggestions-dropdown.active {
      display: block;
    }

    .suggestion-item {
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .suggestion-item:hover,
    .suggestion-item.selected {
      background: var(--text-color);
      color: var(--bg-color);
    }

    .suggestion-description {
      font-size: 0.9em;
      opacity: 0.8;
      margin-left: 20px;
    }
  </style>
</head>
<body>
  <div id="terminal">
    <div class="output" id="welcome-message">
      Welcome to the AI-Powered Terminal Emulator!
      Type <strong>'help'</strong> to see available commands.
      Type <strong>'mode eliza'</strong> to switch to conversation mode.
    </div>
    <div id="input-line">
      <span id="prompt">$</span>
      <label for="input" class="visually-hidden">Command Input</label>
      <input id="input" type="text" autocomplete="off" autofocus placeholder="Type your command here" />
    </div>
  </div>

  <!-- Theme Switcher Button -->
  <div class="theme-switcher" id="theme-switcher">Theme</div>

  <script>
    "use strict";

    class Terminal {
      constructor(outputContainer, inputField, promptElement) {
        this.outputContainer = outputContainer;
        this.inputField = inputField;
        this.promptElement = promptElement;
        this.maxHistorySize = 100; // Limit history size
        this.maxOutputLines = 1000; // Limit output lines

        // Current mode: "terminal" or "eliza"
        this.mode = "terminal";

        // Keep track of command history
        this.commandHistory = this.loadCommandHistory();
        this.historyIndex = this.commandHistory.length;

        // Setup blocked or restricted commands
        this.blockedCommands = ["rm -rf /", "curl", "wget"];

        // Define available themes with transitions
        this.themes = {
          classic: { 
            bg: "#000", 
            text: "#0f0",
            transition: "all 0.3s ease-in-out" 
          },
          light: { 
            bg: "#fafafa", 
            text: "#111",
            transition: "all 0.3s ease-in-out" 
          },
          dark: { 
            bg: "#111", 
            text: "#eee",
            transition: "all 0.3s ease-in-out" 
          },
          matrix: { 
            bg: "#000", 
            text: "#00ff00",
            transition: "all 0.3s ease-in-out" 
          },
          blue: { 
            bg: "#001f3f", 
            text: "#00aced",
            transition: "all 0.3s ease-in-out" 
          }
        };

        // Setup the Eliza conversation logic
        this.elizaResponses = {
          default: ["Why do you say that?", "Can you elaborate?", "What makes you feel this way?"],
          feelings: ["Tell me more about your feelings.", "Do you often feel this way?", "What triggers these emotions?"],
          relationships: ["How are your relationships?", "Is there someone important you'd like to talk about?", "Why do you think this person affects you?"],
          work: ["How is work going for you?", "Do you feel satisfied with your work?", "What challenges are you facing at work?"],
          general: ["Tell me more about that.", "Why do you think so?", "What does this mean to you?"]
        };

        // Enhanced NLP patterns for better understanding
        this.elizaPatterns = {
          feelings: {
            patterns: [
              /(?:i\s+(?:am|feel|felt)\s+)(.*?)(?:\s|$)/i,
              /(?:i'm\s+)(.*?)(?:\s|$)/i,
              /(?:makes?\s+me\s+)(.*?)(?:\s|$)/i
            ],
            responses: [
              "Why do you feel %1?",
              "How long have you felt %1?",
              "Do you often feel %1?",
              "What do you think causes you to feel %1?",
              "When you feel %1, what do you do?"
            ]
          },
          relationships: {
            patterns: [
              /(?:my\s+)((?:mother|father|sister|brother|friend|partner|wife|husband|boyfriend|girlfriend))/i,
              /(?:(\w+)\s+(?:loves?|hates?|likes?)\s+me)/i,
              /(?:i\s+(?:love|hate|like)\s+(\w+))/i
            ],
            responses: [
              "Tell me more about your %1.",
              "How do you feel about your %1?",
              "How long have you known your %1?",
              "What's your earliest memory with your %1?",
              "How has your relationship with your %1 changed over time?"
            ]
          },
          problems: {
            patterns: [
              /(?:i\s+(?:can't|cannot)\s+)(.*?)(?:\s|$)/i,
              /(?:i\s+(?:need|want)\s+to\s+)(.*?)(?:\s|$)/i,
              /(?:(?:always|never)\s+)(.*?)(?:\s|$)/i
            ],
            responses: [
              "What's stopping you from %1?",
              "Have you tried to %1 before?",
              "What would happen if you could %1?",
              "Who could help you %1?",
              "What's the first step towards %1?"
            ]
          },
          memories: {
            patterns: [
              /(?:i\s+remember\s+)(.*?)(?:\s|$)/i,
              /(?:when\s+i\s+was\s+)(.*?)(?:\s|$)/i,
              /(?:used\s+to\s+)(.*?)(?:\s|$)/i
            ],
            responses: [
              "How do you feel when you remember %1?",
              "What other memories do you have about %1?",
              "How has that memory of %1 affected you?",
              "Do you often think about %1?",
              "What triggers these memories of %1?"
            ]
          }
        };

        // Conversation memory and context
        this.conversationMemory = {
          topics: [],
          emotions: [],
          lastResponse: null,
          turnCount: 0,
          recentTopics: new Set()
        };

        // Therapy-oriented decision tree
        this.therapyTree = {
          anxiety: {
            symptoms: ["nervous", "worried", "anxious", "panic", "stress"],
            followUp: [
              "Can you describe what triggers your anxiety?",
              "How does anxiety manifest in your body?",
              "What helps you calm down when you're anxious?",
              "Have you developed any coping mechanisms?"
            ]
          },
          depression: {
            symptoms: ["sad", "depressed", "hopeless", "tired", "empty"],
            followUp: [
              "How long have you been feeling this way?",
              "What activities used to bring you joy?",
              "Have you noticed changes in your sleep or appetite?",
              "Are you getting support from others?"
            ]
          },
          anger: {
            symptoms: ["angry", "mad", "frustrated", "rage", "upset"],
            followUp: [
              "What triggers your anger?",
              "How do you typically express your anger?",
              "What helps you cool down?",
              "Have you tried any anger management techniques?"
            ]
          },
          relationships: {
            symptoms: ["lonely", "relationship", "friend", "family", "partner"],
            followUp: [
              "How do you feel about your current relationships?",
              "What qualities do you value in relationships?",
              "Have you noticed any patterns in your relationships?",
              "How do you handle conflict in relationships?"
            ]
          }
        };

        // Available commands with descriptions
        this.commands = {
          help: { desc: "Display available commands" },
          clear: { desc: "Clear the terminal screen" },
          history: { desc: "Show command history" },
          ls: { desc: "List files" },
          pwd: { desc: "Print working directory" },
          whoami: { desc: "Display current user" },
          "uname -a": { desc: "Display system information" },
          date: { desc: "Show current date/time" },
          df: { desc: "Show disk usage info" },
          uptime: { desc: "Show system uptime" },
          cal: { desc: "Show calendar" },
          "mode eliza": { desc: "Switch to Eliza conversation mode" },
          "mode terminal": { desc: "Switch to terminal mode" },
          "theme list": { desc: "List available themes" },
          exit: { desc: "Terminate this session" }
        };

        // Create suggestions dropdown
        this.suggestionsDropdown = document.createElement('div');
        this.suggestionsDropdown.className = 'suggestions-dropdown';
        this.outputContainer.appendChild(this.suggestionsDropdown);
        
        // Track current suggestion selection
        this.selectedSuggestionIndex = -1;

        // Attach event listeners
        this.init();
        // Load user theme preference if stored
        this.loadThemePreference();
      }

      init() {
        // Ensure input field always maintains focus
        this.inputField.addEventListener("blur", () => {
          setTimeout(() => this.inputField.focus(), 10);
        });

        // Handle paste events
        this.inputField.addEventListener("paste", (event) => {
          event.preventDefault();
          const text = event.clipboardData.getData("text/plain");
          const sanitizedText = this.sanitizeInput(text);
          document.execCommand("insertText", false, sanitizedText);
        });

        // Enhanced keydown handling with suggestions
        this.inputField.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            this.suggestionsDropdown.classList.remove('active');
            const command = this.inputField.value.trim();
            if (command) {
              if (!this.commandHistory.length || 
                  this.commandHistory[this.commandHistory.length - 1] !== command) {
                this.addToHistory(command);
              }
              this.processCommand(command);
              this.inputField.value = "";
              this.historyIndex = this.commandHistory.length;
            }
          }
          else if (event.key === "Tab") {
            event.preventDefault();
            this.handleTabCompletion();
          }
          else if (event.key === "ArrowDown") {
            if (this.suggestionsDropdown.classList.contains('active')) {
              event.preventDefault();
              this.navigateSuggestions(1);
            } else if (this.historyIndex < this.commandHistory.length - 1) {
              this.historyIndex++;
              this.inputField.value = this.commandHistory[this.historyIndex];
            } else {
              this.historyIndex = this.commandHistory.length;
              this.inputField.value = "";
            }
          }
          else if (event.key === "ArrowUp") {
            if (this.suggestionsDropdown.classList.contains('active')) {
              event.preventDefault();
              this.navigateSuggestions(-1);
            } else if (this.historyIndex > 0) {
              this.historyIndex--;
              this.inputField.value = this.commandHistory[this.historyIndex];
            }
          }
          else if (event.key === "Escape") {
            this.suggestionsDropdown.classList.remove('active');
          }
        });

        // Input event for real-time suggestions
        this.inputField.addEventListener("input", () => {
          this.showSuggestions();
        });

        // Click outside to close suggestions
        document.addEventListener('click', (event) => {
          if (!this.suggestionsDropdown.contains(event.target) && 
              event.target !== this.inputField) {
            this.suggestionsDropdown.classList.remove('active');
          }
        });

        // Initialize theme switcher with transitions
        const themeSwitcher = document.getElementById("theme-switcher");
        themeSwitcher.addEventListener("click", () => {
          this.showThemeMenu();
        });
      }

      // New methods for improved UI handling
      sanitizeInput(input) {
        // Remove control characters and normalize whitespace
        return input.replace(/[\x00-\x1F\x7F-\x9F]/g, "")
                   .replace(/\s+/g, " ");
      }

      addToHistory(command) {
        this.commandHistory.push(command);
        // Maintain history size limit
        if (this.commandHistory.length > this.maxHistorySize) {
          this.commandHistory.shift();
        }
        this.saveCommandHistory();
      }

      saveCommandHistory() {
        try {
          localStorage.setItem("terminalHistory", 
            JSON.stringify(this.commandHistory.slice(-this.maxHistorySize))
          );
        } catch (e) {
          console.warn("Could not save command history:", e);
        }
      }

      loadCommandHistory() {
        try {
          const saved = localStorage.getItem("terminalHistory");
          return saved ? JSON.parse(saved) : [];
        } catch (e) {
          console.warn("Could not load command history:", e);
          return [];
        }
      }

      showThemeMenu() {
        const themeNames = Object.keys(this.themes);
        const currentTheme = this.getCurrentTheme();
        
        let themeList = "Available themes:\n";
        themeNames.forEach(name => {
          themeList += `${name === currentTheme ? "* " : "  "}${name}\n`;
        });
        
        this.printOutput(themeList);
      }

      getCurrentTheme() {
        try {
          return localStorage.getItem("preferredTheme") || "classic";
        } catch (e) {
          return "classic";
        }
      }

      switchTheme(themeName) {
        if (themeName === "list") {
          this.showThemeMenu();
          return;
        }

        if (!this.themes[themeName]) {
          this.printOutput(`Invalid theme. Use 'theme list' to see available themes.`);
          return;
        }

        const { bg, text, transition } = this.themes[themeName];
        
        // Apply transition
        document.documentElement.style.transition = transition;
        
        // Apply theme
        document.documentElement.style.setProperty("--bg-color", bg);
        document.documentElement.style.setProperty("--text-color", text);
        document.documentElement.style.setProperty("--prompt-color", text);

        this.printOutput(`Switched to ${themeName} theme.`);
        this.saveThemePreference(themeName);

        // Reset transition after change
        setTimeout(() => {
          document.documentElement.style.transition = "";
        }, 300);
      }

      // Store chosen theme in localStorage
      saveThemePreference(themeName) {
        try {
          localStorage.setItem("preferredTheme", themeName);
        } catch (e) {
          // silently fail if localStorage is not available
        }
      }

      // Load the last-used theme from localStorage if available
      loadThemePreference() {
        try {
          const storedTheme = localStorage.getItem("preferredTheme");
          if (storedTheme && this.themes[storedTheme]) {
            this.switchTheme(storedTheme);
          }
        } catch (e) {
          // do nothing
        }
      }

      // Process each command
      processCommand(command) {
        if (!command) return;
        this.printOutput(`$ ${command}`);

        // Global exit command
        if (command === "exit") {
          this.printOutput("Session terminated. Refresh to start anew.");
          return;
        }

        // Switch modes
        if (command.startsWith("mode ")) {
          const [, modeName] = command.split(" ");
          this.switchMode(modeName);
          return;
        }

        // Switch themes
        if (command.startsWith("theme ")) {
          const [, themeName] = command.split(" ");
          this.switchTheme(themeName);
          return;
        }

        // In Eliza mode, handle conversation
        if (this.mode === "eliza") {
          this.runEliza(command);
          return;
        }

        // If normal terminal mode, parse terminal commands
        this.runTerminal(command);
      }

      switchMode(mode) {
        if (mode === "eliza") {
          this.mode = "eliza";
          this.printOutput("Switched to ELIZA conversation mode. Type 'mode terminal' to go back.");
        } else if (mode === "terminal") {
          this.mode = "terminal";
          this.printOutput("Switched to standard terminal mode.");
        } else {
          this.printOutput(`Invalid mode: ${mode}. Valid modes are: terminal, eliza`);
        }
      }

      // Enhanced ELIZA processing
      runEliza(input) {
        this.conversationMemory.turnCount++;
        const response = this.generateResponse(input);
        this.updateConversationMemory(input, response);
        this.printOutput(`ELIZA: ${response}`);
      }

      generateResponse(input) {
        const lowercaseInput = input.toLowerCase();
        
        // Check for immediate concerns or crisis keywords
        if (this.checkForCrisis(lowercaseInput)) {
          return this.getCrisisResponse();
        }

        // Try to match against therapy patterns
        for (const category in this.elizaPatterns) {
          const patternGroup = this.elizaPatterns[category];
          for (const pattern of patternGroup.patterns) {
            const match = lowercaseInput.match(pattern);
            if (match) {
              const captured = match[1];
              const responses = patternGroup.responses;
              const response = responses[Math.floor(Math.random() * responses.length)];
              return response.replace('%1', captured);
            }
          }
        }

        // Check therapy tree for relevant topics
        for (const topic in this.therapyTree) {
          const symptoms = this.therapyTree[topic].symptoms;
          if (symptoms.some(symptom => lowercaseInput.includes(symptom))) {
            if (!this.conversationMemory.recentTopics.has(topic)) {
              this.conversationMemory.recentTopics.add(topic);
              return this.therapyTree[topic].followUp[
                Math.floor(Math.random() * this.therapyTree[topic].followUp.length)
              ];
            }
          }
        }

        // If no specific pattern matches, use context-aware general response
        return this.getContextAwareResponse(lowercaseInput);
      }

      checkForCrisis(input) {
        const crisisKeywords = ['suicide', 'kill myself', 'end it all', 'die', 'hurt myself'];
        return crisisKeywords.some(keyword => input.includes(keyword));
      }

      getCrisisResponse() {
        return "I hear that you're in pain. Please know that help is available. " +
               "Consider calling a crisis helpline (1-800-273-8255) or reaching out to a mental health professional. " +
               "Would you like to talk more about what's troubling you?";
      }

      getContextAwareResponse(input) {
        // Use conversation memory to generate more contextual responses
        if (this.conversationMemory.turnCount < 2) {
          return "Can you tell me more about what brings you here today?";
        }

        if (this.conversationMemory.emotions.length > 0) {
          const lastEmotion = this.conversationMemory.emotions[this.conversationMemory.emotions.length - 1];
          return `Earlier you mentioned feeling ${lastEmotion}. How are you feeling now?`;
        }

        // Default to general therapeutic responses
        const generalResponses = [
          "How does that make you feel?",
          "What thoughts come up when you consider this?",
          "Can you elaborate on that?",
          "How do you think this relates to your current situation?",
          "What would be different if you could change this?"
        ];

        return generalResponses[Math.floor(Math.random() * generalResponses.length)];
      }

      updateConversationMemory(input, response) {
        // Store recent topics and emotions
        const emotions = this.extractEmotions(input);
        if (emotions.length > 0) {
          this.conversationMemory.emotions = [
            ...this.conversationMemory.emotions,
            ...emotions
          ].slice(-5); // Keep last 5 emotions
        }

        this.conversationMemory.lastResponse = response;
        
        // Limit topics memory to last 10 topics
        if (this.conversationMemory.topics.length > 10) {
          this.conversationMemory.topics.shift();
        }
      }

      extractEmotions(input) {
        const emotionWords = [
          'happy', 'sad', 'angry', 'scared', 'anxious', 'excited', 
          'worried', 'confused', 'frustrated', 'lonely', 'proud',
          'guilty', 'ashamed', 'grateful', 'hopeful', 'desperate'
        ];
        
        return emotionWords.filter(emotion => 
          input.toLowerCase().includes(emotion)
        );
      }

      // Expanding terminal commands
      runTerminal(command) {
        // Check for blocked commands
        if (this.blockedCommands.some((blocked) => command.includes(blocked))) {
          this.printOutput(`Permission denied: executing '${command}' is not allowed.`);
          return;
        }

        switch (true) {
          case command === "help":
            this.printOutput(
              "Available Commands:\n" +
              "  help                Display this help text\n" +
              "  clear               Clear the terminal screen\n" +
              "  history             Show command history\n" +
              "  ls                  List files\n" +
              "  pwd                 Print working directory\n" +
              "  whoami              Display current user\n" +
              "  uname -a            Display system information\n" +
              "  date                Show current date/time\n" +
              "  df                  Show disk usage info\n" +
              "  uptime              Show system uptime\n" +
              "  cal                 Show calendar\n" +
              "  touch <file>        Create empty file\n" +
              "  mkdir <dir>         Create directory\n" +
              "  mode eliza          Switch to Eliza conversation mode\n" +
              "  mode terminal       Switch to standard terminal mode\n" +
              "  theme list          List available themes\n" +
              "  theme <name>        Switch to specific theme\n" +
              "  exit                Terminate this session"
            );
            break;

          case command === "clear":
            // Clear everything except the last input line
            this.clearTerminal();
            break;

          case command === "history":
            this.printOutput(this.commandHistory.join("\n"));
            break;

          case command === "ls":
            this.printOutput("Desktop  Documents  Downloads  Music  Pictures  Videos");
            break;

          case command === "pwd":
            this.printOutput("/home/user");
            break;

          case command === "whoami":
            this.printOutput("user");
            break;

          case command === "uname -a":
            this.printOutput("Linux localhost 5.4.0-42-generic x86_64");
            break;

          case command === "date":
            this.printOutput(new Date().toString());
            break;

          case command === "df":
            this.printOutput("Filesystem     1K-blocks     Used Available Use% Mounted on\n/dev/sda1      488281250 100000000  388281250  20% /");
            break;

          case command === "uptime":
            this.printOutput(" 10:24:10 up 5 days,  4:52,  3 users,  load average: 0.00, 0.01, 0.05");
            break;

          case command === "cal":
            // Example partial monthly calendar
            this.printOutput(
              "    January 2025   \n" +
              "Su Mo Tu We Th Fr Sa\n" +
              "      1  2  3  4\n" +
              " 5  6  7  8  9 10 11\n" +
              "12 13 14 15 16 17 18\n" +
              "19 20 21 22 23 24 25\n" +
              "26 27 28 29 30 31"
            );
            break;

          case command.startsWith("touch"):
            {
              const fileName = command.split(" ")[1];
              if (!fileName) {
                this.printOutput("No file specified. Usage: touch <filename>");
              } else {
                this.printOutput(`Created file: ${fileName}`);
              }
            }
            break;

          case command.startsWith("mkdir"):
            {
              const dirName = command.split(" ")[1];
              if (!dirName) {
                this.printOutput("No directory specified. Usage: mkdir <dirname>");
              } else {
                this.printOutput(`Created directory: ${dirName}`);
              }
            }
            break;

          default:
            this.printOutput(`bash: ${command.split(" ")[0]}: command not found`);
        }
      }

      // Clear output except for an optional welcome message
      clearTerminal() {
        // Remove all .output nodes except input-line
        const children = Array.from(this.outputContainer.childNodes);
        children.forEach((child) => {
          if (child.id !== "input-line") {
            this.outputContainer.removeChild(child);
          }
        });
      }

      // Enhanced output management
      printOutput(message) {
        const outputDiv = document.createElement("div");
        outputDiv.className = "output";
        outputDiv.textContent = message;
        
        // Insert before the input line
        this.outputContainer.insertBefore(outputDiv, document.getElementById("input-line"));
        
        // Limit number of output lines
        this.pruneOutput();
        
        // Smooth scroll to bottom
        this.outputContainer.scrollTo({
          top: this.outputContainer.scrollHeight,
          behavior: "smooth"
        });
      }

      pruneOutput() {
        const outputs = this.outputContainer.getElementsByClassName("output");
        while (outputs.length > this.maxOutputLines) {
          outputs[0].remove();
        }
      }

      showSuggestions() {
        const input = this.inputField.value.toLowerCase();
        if (!input) {
          this.suggestionsDropdown.classList.remove('active');
          return;
        }

        const matches = Object.entries(this.commands)
          .filter(([cmd]) => cmd.toLowerCase().includes(input))
          .sort((a, b) => {
            // Prioritize commands that start with input
            const aStarts = a[0].toLowerCase().startsWith(input);
            const bStarts = b[0].toLowerCase().startsWith(input);
            if (aStarts && !bStarts) return -1;
            if (!aStarts && bStarts) return 1;
            return a[0].localeCompare(b[0]);
          })
          .slice(0, 8); // Limit to 8 suggestions

        if (matches.length === 0) {
          this.suggestionsDropdown.classList.remove('active');
          return;
        }

        this.suggestionsDropdown.innerHTML = matches
          .map(([cmd, { desc }], index) => `
            <div class="suggestion-item" data-command="${cmd}">
              <span class="suggestion-command">${cmd}</span>
              <span class="suggestion-description">${desc}</span>
            </div>
          `).join('');

        this.suggestionsDropdown.classList.add('active');
        this.selectedSuggestionIndex = -1;

        // Add click handlers to suggestions
        this.suggestionsDropdown.querySelectorAll('.suggestion-item').forEach(item => {
          item.addEventListener('click', () => {
            this.inputField.value = item.dataset.command;
            this.suggestionsDropdown.classList.remove('active');
            this.inputField.focus();
          });
        });
      }

      navigateSuggestions(direction) {
        const suggestions = this.suggestionsDropdown.querySelectorAll('.suggestion-item');
        if (!suggestions.length) return;

        // Remove previous selection
        suggestions[this.selectedSuggestionIndex]?.classList.remove('selected');

        // Update selection index
        this.selectedSuggestionIndex += direction;
        if (this.selectedSuggestionIndex >= suggestions.length) {
          this.selectedSuggestionIndex = 0;
        } else if (this.selectedSuggestionIndex < 0) {
          this.selectedSuggestionIndex = suggestions.length - 1;
        }

        // Apply new selection
        const selectedItem = suggestions[this.selectedSuggestionIndex];
        selectedItem.classList.add('selected');
        this.inputField.value = selectedItem.dataset.command;
      }

      handleTabCompletion() {
        const suggestions = this.suggestionsDropdown.querySelectorAll('.suggestion-item');
        if (suggestions.length === 1) {
          // If only one suggestion, use it
          this.inputField.value = suggestions[0].dataset.command;
          this.suggestionsDropdown.classList.remove('active');
        } else if (suggestions.length > 1 && this.selectedSuggestionIndex >= 0) {
          // If multiple suggestions and one is selected, use the selected one
          this.inputField.value = suggestions[this.selectedSuggestionIndex].dataset.command;
          this.suggestionsDropdown.classList.remove('active');
        }
      }
    }

    // Initialize Terminal instance
    const terminalElement = document.getElementById("terminal");
    const inputElement = document.getElementById("input");
    const promptElement = document.getElementById("prompt");
    const terminal = new Terminal(terminalElement, inputElement, promptElement);
  </script>
</body>
</html>